<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">		
		<title>CartoDB API Queries – Map Interfaces 2012</title>
		<!-- Bootstrap -->
		<link href="http://twitter.github.com/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">
		<link href="../css/bootstrap.min.css" rel="stylesheet">
		<link href="../css/bootstrap-responsive.min.css" rel="stylesheet">
		<link href="../css/custom.css" rel="stylesheet">
		<script src="http://twitter.github.com/bootstrap/assets/js/google-code-prettify/prettify.js"></script>

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
		  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->		

    </head>
    <body onload="prettyPrint()">
		<div class="navbar navbar-inverse navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="#">Map Interfaces</a>
					<div class="nav-collapse collapse">
						<ul class="nav">
							<li><a href="../">Home</a></li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Grundlagen <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li class="nav-header">Leaflet</li>
									<li><a href="leaflet-basic.html">Leaflet Setup</a></li>
									<li><a href="leaflet-providers.html">Kartenprovider</a></li>
									<li><a href="leaflet-markers.html">Marker setzen</a></li>
									<li><a href="leaflet-marker-json.html">Marker aus JSON</a></li>
									<li><a href="leaflet-geojson.html">GeoJSON anzeigen</a></li>
									<li><a href="leaflet-image.html">Bilder einbetten</a></li>
									<li class="divider"></li>
									<li class="nav-header">CartoDB</li>
									<li><a href="leaflet-cartodb.html">CartoDB APIs</a></li>
									<li><a href="leaflet-cartodbqueries.html">CartoDB Queries</a></li>
								</ul>
							</li>
						</ul>
						<!--						<form class="navbar-form pull-right">
													<input class="span2" type="text" placeholder="Email">
													<input class="span2" type="password" placeholder="Password">
													<button type="submit" class="btn">Sign in</button>
												</form>-->
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>

		<div class="container">

			<!-- Main hero unit for a primary marketing message or call to action -->
			<div class="hero-unit">
				<h1>CartoDB Queries</h1>
				<p>Eine Einführung in selbsterstellte Abfragen für die CartoDB API. Wir nutzen hier <a href="http://api.jquery.com/jQuery.getJSON/">jQuery</a> zur direkten Kommunikation mit der Schnittstelle, <a href="http://en.wikipedia.org/wiki/SQL">SQL</a> um eigene Abfragen zu formulieren und <a href="http://www.postgis.org/documentation/">PostGIS</a> Funktionen um georäumliche Operationen in unseren Abfragen durchzuführen.</p>
				<!--<p><a class="btn btn-primary btn-large">Learn more &raquo;</a></p>-->
			</div>

			<div class="row">
				<div class="span12">
					<iframe class="map" src="leaflet-cartodbqueries-clean.html"></iframe>
				</div>
				<div class="span12">
					<a href="leaflet-cartodbqueries-clean.html">Nur das Beispiel anzeigen</a>
				</div>
			</div>
			<div class="row">
				<div class="span12">
					Wieder nutzen wir unser Basis-Setup mit Leaflet. Die einzige Erweiterung besteht in dem hinzugefügten Formular-Element (der &lt;select&gt;-Box), welches wir als Overlay auf der Karte positioniert haben.
				</div>
			</div>
			<div class="row">
				<div class="span12">
					index.html
				</div>				
				<div class="span12">
					<pre class="prettyprint lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;Leaflet CartoDB Setup&lt;/title&gt;
		&lt;!-- Dieses Beispiel nutzt die CDN Version (online) der Leaflet Bibliothek. 
		Dazu muss man beim Ausprobieren der Beispiele online sein. 
		Wer das nicht m&ouml;chte kann wieder auf das Setup aus dem Basic Example zur&uuml;ckgreifen. --&gt;
		&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.leafletjs.com/leaflet-0.4.5/leaflet.css&quot; /&gt;
		&lt;!--[if lte IE 8]&gt;
			&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.leafletjs.com/leaflet-0.4.5/leaflet.ie.css&quot; /&gt;
		&lt;![endif]--&gt;
		&lt;!-- Neu, wir nutzen dieses Mal jQuery statt des CartoDB-Plugins --&gt;
		&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;		
		&lt;script src=&quot;http://cdn.leafletjs.com/leaflet-0.4.5/leaflet.js&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot; src=&quot;leaflet-cartodbqueries.js&quot;&gt;&lt;/script&gt;		
		&lt;style&gt;
			html, body { margin:0; padding: 0; }
			#map { min-height: 400px; }
			#overlay {
				position: absolute;
				top: 20px;
				right: 20px;
				text-align: right;
				background-color: rgba(0,0,0, .2);
				border-radius: 5px;
				padding: 5px;
			}
			.licence { font-size: 10px; font-family: sans-serif; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;
		&lt;div id=&quot;overlay&quot;&gt;
			&lt;select size=&quot;1&quot; name=&quot;bezirk&quot; id=&quot;select-bezirk&quot;&gt;&lt;option value=&quot;&quot;&gt;Bezirk ausw&auml;hlen...&lt;/option&gt;&lt;/select&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;</<pre>
				</div>
			</div>
			<div class="row">
				<div class="span12">
					Der Aufbau der JavaScript-Datei ist jetzt schon etwas umfangreicher. Die $(document).ready();-Konstruktion sorgt dafür, dass der JavaScript-Code erst dann ausgeführt wird, wenn der Rest der Webseite fertig geladen ist.
					Diese kleine Applikation wird durch Benutzer-Events gesteuert (event-driven) und arbeitet viel mit <a href="http://recurial.com/programming/understanding-callback-functions-in-javascript/">Callback</a>-Funktionen in JavaScript.
				</div>								
			</div>
			<div class="row">
				<div class="span12">
					map.js
				</div>								
				<div class="span12">
					<pre class="prettyprint lang-js">/* Map Interfaces 2012 – FH Potsdam
 * 
 * Basic Leaflet Setup als Beispielprojekt
 * 
 * @author	Marcus Paeschke
 * @licence	cc-by-sa
 */

$(document).ready(function () {
	


/**
 * Step 1: Zuerst muss Leaflet initialisiert werden, der Einfachheit halber speichern wir das Objekt in der Variable "map"
 */
	var map = L.map('map', {
		center : [52.52, 13.4],
		zoom : 13
	});


/**
 * Step 2: Im Beispiel verwenden wir als Quelle für unseren TileLayer eine CloudMade Karte.
 * 
 * L.tileLayer('url', { options }) erzeugt einen neuen TileLayer
 * .addTo(Objekt) fügt den neuen Layer unserer Karte hinzu, im Beispiel "map"
 * 
 */

	L.tileLayer('http://{s}.tile.cloudmade.com/5c5f709891f240bbba32d5f42f1926ec/997/256/{z}/{x}/{y}.png').addTo(map);

/**
 * Step 3: Im folgenden Beispiel wollen wir eine kleine App bauen, die es mir ermöglicht einen der Berliner Bezirke auszuwählen und alle Haltestellen des öffentlichen Nahverkehrs in diesem Bezirk anzusehen.
 * 
 * Dazu bereiten wir uns zuerst ein paar Variablen für Leaflet-Ebenen vor.
 * Die Variable layer.bezirk soll später den GeoJSON-Layer mit dem Umriss des Bezirks enthalten
 * Die Variable layer.stops wird eine FeatureGroup, wo wir alle Marker zu den Haltestellen zwischenspeichern
 */
	
	var layer = {
		bezirk : null,
		stops : L.featureGroup()
	}

/**
 * Step 4: Hier arbeiten wir nun mit selbstgebauten API Anfragen und der CartoDB-SQL-API
 * 
 * Als erstes lassen wir uns eine Liste der Berliner Bezirke ausgeben.
 * Wir werden die Liste nutzen, um eine vorher im HTML Dokument hinzugefügte SELECT-Box mit Inhalten zu befüllen.
 * 
 * Die Anfragen an die CartoDB-SQL-API werden logischerweise auch in der SQL-Syntax geschrieben. (SQL ist eine eigene Sprache zur Datenbank-Abfrage)
 * Im Beispiel rufen wir die Spalten "cartodb_id" und "name" aus der Tabelle "berlin_bezirke" ab und ordnen das Ergebnis alphabetisch nach der Spalte "name".
 * Die Formulierung dieser Datenbank-Abfrage speichern wir zunächst in einer Variable, ohne die Anfrage sofort auszuführen.
 */

	var query = 'SELECT cartodb_id, name FROM berlin_bezirke ORDER BY name';
	
/**
 * Step 5: Jetzt wo die Anfrage formuliert ist, werden wir jQuery benutzen um die Anfrage an die Datenbank zu schicken und das Ergebnis abzuwarten.
 * 
 * Wichtig ist, dass die Abfrage an die richtige URL geschickt wird, und damit die Anfrage lesbar ankommt, muss sie noch so kodiert werden, dass sie URL-Kompatibel ist.
 * Dazu benutzen wir encodeURIComponent um das eigentliche "query" zu kodieren.
 * 
 * An der Stelle "function (response) {}" übergeben wir eine sogenannte Callback-Funktion, die aufgerufen wird, sobald die Antwort vom Datenbank-Server eingetroffen ist.
 */

	$.getJSON('http://marcus.maps-fhp.de:8080/api/v1/sql?q='+ encodeURIComponent(query), function(response) {
		$select = $("#select-bezirk");
		// Für jeden Bezirk den wir in der Antwort vorfinden, fügen wir der Select-Box eine neue Option hinzu
		$.each(response.rows, function (index, obj) {
			$select.append('&lt;option value="' + obj.cartodb_id + '"&gt;' + obj.name + '&lt;/option&gt;');
		});
		// Hier definieren wir einen Event-Handler (wieder eine Callback-Funktion) die immer dann aufgerufen wird, wenn der Benutzer die Auswahl in der Select-Box verändert.
		$select.change(updateMap);

	});
	
	// Diese Funktion ist unser Eevent-Handler (ausgelöst durch eine Auswahl in der Select-Box)
	var updateMap = function (event) {
		// Zuerst lesen wir aus dem Event, welchen Bezirk der Benutzer ausgewählt hat
		var cartodb_id_bezirk = event.target.value;
		
		// dann überprüfen wir, ob die Auswahl auch Sinn macht.
		if(cartodb_id_bezirk != "") {
		
			// Mit dem Bezirk rufen wir jetzt alle vorhandenen Daten (inkl. der Geometrie) zu dem ausgewählten Bezirk ab.
			// man beachte das angehängte &format=geojson in der URL
			// man beachte außerdem die Verwendung von PostGIS-Funktionen (ST_...) innerhalb des SQL-Queries
			// mit der Funktion ST_Centroid berechnen wir die geometrische Mitte des Bezirks
			$.getJSON('http://marcus.maps-fhp.de:8080/api/v1/sql?q='+ encodeURIComponent("SELECT *, ST_X(ST_Centroid(the_geom)) AS center_x, ST_Y(ST_Centroid(the_geom)) AS center_y FROM berlin_bezirke WHERE cartodb_id = '" + cartodb_id_bezirk + "'") + "&format=geojson", function(response) {
				if(response && response.features && response.features[0]) {
					// wurde vorher bereits ein Bezirk angezeigt, entfernen wir den zunächst von der Karte
					layer.bezirk && map.removeLayer(layer.bezirk);
					// jetzt erzeugen wir einen neuen GeoJSON Layer mit dem Umriss des Bezirks
					layer.bezirk = L.geoJson(response.features[0]);
					// anschließend wird der Bezirk der Karte hinzugefügt (damit er auch angezeigt wird)
					layer.bezirk.addTo(map);
					// hier suchen wir uns die Mitte des Bezirks heraus und verschieben die Karte zum neuen Mittelpunkt (damit der Benutzer auch sieht, was er ausgewählt hat)
					var props = response.features[0].properties;
					map.panTo([props.center_y, props.center_x]);				
				
				} else {
					console.log('Error loading shape from Bezirk');
				}
			});
		
			// Mit einer 2. Abfrage lesen wir alle Haltestellen innerhalb des Bezirks aus
			// dieses SQL-Query ist schon relativ komplex - hier werden die Daten aus der einen Tabelle genommen und mit den Daten aus der anderen Tabelle verschnitten
			// wie suchen uns also zuerst die Umrisse des Bezirks heraus und laden dann alle Haltestellen herunter die innerhalb dieser Umrisse sind (ST_Contains)
			$.getJSON('http://marcus.maps-fhp.de:8080/api/v1/sql?q='+ encodeURIComponent("SELECT t2.* FROM berlin_bezirke AS t1, vbb_stops AS t2 WHERE t1.cartodb_id = '" + cartodb_id_bezirk + "' AND ST_Contains(t1.the_geom, t2.the_geom)") + "&format=geojson", function(response) {			
				map.removeLayer(layer.stops);
				if(response && response.features) {
					// Bevor wir die neuen Haltestellen anzeigen, entfernen wir die alten aus der FeatureGroup
					layer.stops.clearLayers();
					// Jetzt erzeugen wir für jede Haltestelle eine Markierung, inklusive PopUp mit dem Namen der Haltestelle
					$.each(response.features, function(index, feature) {
						var lnglat = feature.geometry.coordinates;
						var marker = L.marker([lnglat[1], lnglat[0]]);
						marker.bindPopup('&lt;h2&gt;' + feature.properties.stop_name + '&lt;/h2&gt;');
						// hier wird der Marker der FeatureGroup hinzugefügt
						layer.stops.addLayer(marker);
					})
				}			
				// am Ende müssen wir die FeatureGroup wieder auf der Karte anzeigen
				layer.stops.addTo(map);
			});
		} else {
			// hat der Nutzer keinen Bezirk ausgewählt, entfernen wir die zuletzt angezeigten Layer wieder
			map.removeLayer(layer.bezirk);
			map.removeLayer(layer.stops);
		}
	}
});</pre>
								</div>
							</div>

							<hr>

							<footer>
								<p>&copy; Interfacedesign · FH Potsdam · 2012</p>
							</footer>

							</div> <!-- /container -->



							<script src="http://code.jquery.com/jquery-latest.js"></script>
							<script src="../js/bootstrap.min.js"></script>


							</body>
							</html>